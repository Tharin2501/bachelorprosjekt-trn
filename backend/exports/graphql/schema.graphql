type Article {
  name: String
  description: String
  image(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
  _id: ID!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ArticleAggregator {
  count: Int
  totalCount: Int
}

type ArticleConnection {
  values: [Article]
  groupBy: ArticleGroupBy
  aggregate: ArticleAggregator
}

type ArticleConnection_id {
  key: ID
  connection: ArticleConnection
}

type ArticleConnectionCreatedAt {
  key: DateTime
  connection: ArticleConnection
}

type ArticleConnectionDescription {
  key: String
  connection: ArticleConnection
}

type ArticleConnectionId {
  key: ID
  connection: ArticleConnection
}

type ArticleConnectionName {
  key: String
  connection: ArticleConnection
}

type ArticleConnectionUpdatedAt {
  key: DateTime
  connection: ArticleConnection
}

type ArticleGroupBy {
  name: [ArticleConnectionName]
  description: [ArticleConnectionDescription]
  _id: [ArticleConnection_id]
  id: [ArticleConnectionId]
  createdAt: [ArticleConnectionCreatedAt]
  updatedAt: [ArticleConnectionUpdatedAt]
}

input ArticleInput {
  name: String
  description: String
  image: [ID]
}

type Author {
  name: String
  email: String
  tittle: String
  _id: ID!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AuthorAggregator {
  count: Int
  totalCount: Int
}

type AuthorConnection {
  values: [Author]
  groupBy: AuthorGroupBy
  aggregate: AuthorAggregator
}

type AuthorConnection_id {
  key: ID
  connection: AuthorConnection
}

type AuthorConnectionCreatedAt {
  key: DateTime
  connection: AuthorConnection
}

type AuthorConnectionEmail {
  key: String
  connection: AuthorConnection
}

type AuthorConnectionId {
  key: ID
  connection: AuthorConnection
}

type AuthorConnectionName {
  key: String
  connection: AuthorConnection
}

type AuthorConnectionTittle {
  key: String
  connection: AuthorConnection
}

type AuthorConnectionUpdatedAt {
  key: DateTime
  connection: AuthorConnection
}

type AuthorGroupBy {
  name: [AuthorConnectionName]
  email: [AuthorConnectionEmail]
  tittle: [AuthorConnectionTittle]
  _id: [AuthorConnection_id]
  id: [AuthorConnectionId]
  createdAt: [AuthorConnectionCreatedAt]
  updatedAt: [AuthorConnectionUpdatedAt]
}

input AuthorInput {
  name: String
  email: String
  tittle: String
}

type BulletPointOnSkincareProduct {
  name: String
  description: String
  IsTrue: Boolean
  _id: ID!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BulletPointOnSkincareProductAggregator {
  count: Int
  totalCount: Int
}

type BulletPointOnSkincareProductConnection {
  values: [BulletPointOnSkincareProduct]
  groupBy: BulletPointOnSkincareProductGroupBy
  aggregate: BulletPointOnSkincareProductAggregator
}

type BulletPointOnSkincareProductConnection_id {
  key: ID
  connection: BulletPointOnSkincareProductConnection
}

type BulletPointOnSkincareProductConnectionCreatedAt {
  key: DateTime
  connection: BulletPointOnSkincareProductConnection
}

type BulletPointOnSkincareProductConnectionDescription {
  key: String
  connection: BulletPointOnSkincareProductConnection
}

type BulletPointOnSkincareProductConnectionId {
  key: ID
  connection: BulletPointOnSkincareProductConnection
}

type BulletPointOnSkincareProductConnectionIsTrue {
  key: Boolean
  connection: BulletPointOnSkincareProductConnection
}

type BulletPointOnSkincareProductConnectionName {
  key: String
  connection: BulletPointOnSkincareProductConnection
}

type BulletPointOnSkincareProductConnectionUpdatedAt {
  key: DateTime
  connection: BulletPointOnSkincareProductConnection
}

type BulletPointOnSkincareProductGroupBy {
  name: [BulletPointOnSkincareProductConnectionName]
  description: [BulletPointOnSkincareProductConnectionDescription]
  IsTrue: [BulletPointOnSkincareProductConnectionIsTrue]
  _id: [BulletPointOnSkincareProductConnection_id]
  id: [BulletPointOnSkincareProductConnectionId]
  createdAt: [BulletPointOnSkincareProductConnectionCreatedAt]
  updatedAt: [BulletPointOnSkincareProductConnectionUpdatedAt]
}

input BulletPointOnSkincareProductInput {
  name: String
  description: String
  IsTrue: Boolean
}

type Category {
  name: String
  description: String
  image: UploadFile
  sub_categories(sort: String, limit: Int, start: Int, where: JSON): [SubCategory]
  _id: ID!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CategoryAggregator {
  count: Int
  totalCount: Int
}

type CategoryConnection {
  values: [Category]
  groupBy: CategoryGroupBy
  aggregate: CategoryAggregator
}

type CategoryConnection_id {
  key: ID
  connection: CategoryConnection
}

type CategoryConnectionCreatedAt {
  key: DateTime
  connection: CategoryConnection
}

type CategoryConnectionDescription {
  key: String
  connection: CategoryConnection
}

type CategoryConnectionId {
  key: ID
  connection: CategoryConnection
}

type CategoryConnectionImage {
  key: ID
  connection: CategoryConnection
}

type CategoryConnectionName {
  key: String
  connection: CategoryConnection
}

type CategoryConnectionUpdatedAt {
  key: DateTime
  connection: CategoryConnection
}

type CategoryGroupBy {
  name: [CategoryConnectionName]
  description: [CategoryConnectionDescription]
  image: [CategoryConnectionImage]
  _id: [CategoryConnection_id]
  id: [CategoryConnectionId]
  createdAt: [CategoryConnectionCreatedAt]
  updatedAt: [CategoryConnectionUpdatedAt]
}

input CategoryInput {
  name: String
  description: String
  image: ID
  sub_categories: [ID]
}

input createArticleInput {
  data: ArticleInput
}

type createArticlePayload {
  article: Article
}

input createAuthorInput {
  data: AuthorInput
}

type createAuthorPayload {
  author: Author
}

input createBulletPointOnSkincareProductInput {
  data: BulletPointOnSkincareProductInput
}

type createBulletPointOnSkincareProductPayload {
  bulletPointOnSkincareProduct: BulletPointOnSkincareProduct
}

input createCategoryInput {
  data: CategoryInput
}

type createCategoryPayload {
  category: Category
}

input createRoleInput {
  data: RoleInput
}

type createRolePayload {
  role: UsersPermissionsRole
}

input createSkincareProductInput {
  data: SkincareProductInput
}

type createSkincareProductPayload {
  skincareProduct: SkincareProduct
}

input createSubCategoryInput {
  data: SubCategoryInput
}

type createSubCategoryPayload {
  subCategory: SubCategory
}

input createTypeOfSkincareProductInput {
  data: TypeOfSkincareProductInput
}

type createTypeOfSkincareProductPayload {
  typeOfSkincareProduct: TypeOfSkincareProduct
}

input createUserInput {
  data: UserInput
}

type createUserPayload {
  user: UsersPermissionsUser
}

"""
A date string, such as 2007-12-03, compliant with the `full-date` format
outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for
representation of dates and times using the Gregorian calendar.
"""
scalar Date

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input deleteArticleInput {
  where: InputID
}

type deleteArticlePayload {
  article: Article
}

input deleteAuthorInput {
  where: InputID
}

type deleteAuthorPayload {
  author: Author
}

input deleteBulletPointOnSkincareProductInput {
  where: InputID
}

type deleteBulletPointOnSkincareProductPayload {
  bulletPointOnSkincareProduct: BulletPointOnSkincareProduct
}

input deleteCategoryInput {
  where: InputID
}

type deleteCategoryPayload {
  category: Category
}

input deleteRoleInput {
  where: InputID
}

type deleteRolePayload {
  role: UsersPermissionsRole
}

input deleteSkincareProductInput {
  where: InputID
}

type deleteSkincareProductPayload {
  skincareProduct: SkincareProduct
}

input deleteSubCategoryInput {
  where: InputID
}

type deleteSubCategoryPayload {
  subCategory: SubCategory
}

input deleteTypeOfSkincareProductInput {
  where: InputID
}

type deleteTypeOfSkincareProductPayload {
  typeOfSkincareProduct: TypeOfSkincareProduct
}

input deleteUserInput {
  where: InputID
}

type deleteUserPayload {
  user: UsersPermissionsUser
}

input editArticleInput {
  name: String
  description: String
  image: [ID]
}

input editAuthorInput {
  name: String
  email: String
  tittle: String
}

input editBulletPointOnSkincareProductInput {
  name: String
  description: String
  IsTrue: Boolean
}

input editCategoryInput {
  name: String
  description: String
  image: ID
  sub_categories: [ID]
}

input editFileInput {
  name: String
  hash: String
  sha256: String
  ext: String
  mime: String
  size: Float
  url: String
  provider: String
  provider_metadata: JSON
  related: [ID]
}

input editRoleInput {
  name: String
  description: String
  type: String
  permissions: [ID]
  users: [ID]
}

input editSkincareProductInput {
  name: String
  type_of_skincare_product: ID
  bullet_point_on_skincare_products: [ID]
}

input editSubCategoryInput {
  name: String
  description: String
  image: [ID]
  category: ID
}

input editTypeOfSkincareProductInput {
  name: String
}

input editUserInput {
  username: String
  email: String
  provider: String
  password: String
  resetPasswordToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
}

input FileInput {
  name: String!
  hash: String!
  sha256: String
  ext: String
  mime: String!
  size: Float!
  url: String!
  provider: String!
  provider_metadata: JSON
  related: [ID]
}

input InputID {
  id: ID!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""The `Long` scalar type represents 52-bit integers"""
scalar Long

union Morph = UsersPermissionsMe | UsersPermissionsMeRole | UsersPermissionsLoginPayload | Article | createArticlePayload | updateArticlePayload | deleteArticlePayload | ArticleConnection | ArticleAggregator | ArticleGroupBy | ArticleConnectionName | ArticleConnectionDescription | ArticleConnection_id | ArticleConnectionId | ArticleConnectionCreatedAt | ArticleConnectionUpdatedAt | Author | createAuthorPayload | updateAuthorPayload | deleteAuthorPayload | AuthorConnection | AuthorAggregator | AuthorGroupBy | AuthorConnectionName | AuthorConnectionEmail | AuthorConnectionTittle | AuthorConnection_id | AuthorConnectionId | AuthorConnectionCreatedAt | AuthorConnectionUpdatedAt | BulletPointOnSkincareProduct | createBulletPointOnSkincareProductPayload | updateBulletPointOnSkincareProductPayload | deleteBulletPointOnSkincareProductPayload | BulletPointOnSkincareProductConnection | BulletPointOnSkincareProductAggregator | BulletPointOnSkincareProductGroupBy | BulletPointOnSkincareProductConnectionName | BulletPointOnSkincareProductConnectionDescription | BulletPointOnSkincareProductConnectionIsTrue | BulletPointOnSkincareProductConnection_id | BulletPointOnSkincareProductConnectionId | BulletPointOnSkincareProductConnectionCreatedAt | BulletPointOnSkincareProductConnectionUpdatedAt | Category | createCategoryPayload | updateCategoryPayload | deleteCategoryPayload | CategoryConnection | CategoryAggregator | CategoryGroupBy | CategoryConnectionName | CategoryConnectionDescription | CategoryConnectionImage | CategoryConnection_id | CategoryConnectionId | CategoryConnectionCreatedAt | CategoryConnectionUpdatedAt | SkincareProduct | createSkincareProductPayload | updateSkincareProductPayload | deleteSkincareProductPayload | SkincareProductConnection | SkincareProductAggregator | SkincareProductGroupBy | SkincareProductConnectionName | SkincareProductConnectionType_of_skincare_product | SkincareProductConnection_id | SkincareProductConnectionId | SkincareProductConnectionCreatedAt | SkincareProductConnectionUpdatedAt | SubCategory | createSubCategoryPayload | updateSubCategoryPayload | deleteSubCategoryPayload | SubCategoryConnection | SubCategoryAggregator | SubCategoryGroupBy | SubCategoryConnectionName | SubCategoryConnectionDescription | SubCategoryConnectionCategory | SubCategoryConnection_id | SubCategoryConnectionId | SubCategoryConnectionCreatedAt | SubCategoryConnectionUpdatedAt | TypeOfSkincareProduct | createTypeOfSkincareProductPayload | updateTypeOfSkincareProductPayload | deleteTypeOfSkincareProductPayload | TypeOfSkincareProductConnection | TypeOfSkincareProductAggregator | TypeOfSkincareProductGroupBy | TypeOfSkincareProductConnectionName | TypeOfSkincareProductConnection_id | TypeOfSkincareProductConnectionId | TypeOfSkincareProductConnectionCreatedAt | TypeOfSkincareProductConnectionUpdatedAt | UploadFile | UploadFileConnection | UploadFileAggregator | UploadFileGroupBy | UploadFileConnectionName | UploadFileConnectionHash | UploadFileConnectionSha256 | UploadFileConnectionExt | UploadFileConnectionMime | UploadFileConnectionSize | UploadFileConnectionUrl | UploadFileConnectionProvider | UploadFileConnectionProvider_metadata | UploadFileConnection_id | UploadFileConnectionId | UploadFileConnectionCreatedAt | UploadFileConnectionUpdatedAt | UsersPermissionsPermission | UsersPermissionsRole | createRolePayload | updateRolePayload | deleteRolePayload | UsersPermissionsRoleConnection | UsersPermissionsRoleAggregator | UsersPermissionsRoleGroupBy | UsersPermissionsRoleConnectionName | UsersPermissionsRoleConnectionDescription | UsersPermissionsRoleConnectionType | UsersPermissionsRoleConnection_id | UsersPermissionsRoleConnectionId | UsersPermissionsRoleConnectionCreatedAt | UsersPermissionsRoleConnectionUpdatedAt | UsersPermissionsUser | createUserPayload | updateUserPayload | deleteUserPayload | UsersPermissionsUserConnection | UsersPermissionsUserAggregator | UsersPermissionsUserGroupBy | UsersPermissionsUserConnectionUsername | UsersPermissionsUserConnectionEmail | UsersPermissionsUserConnectionProvider | UsersPermissionsUserConnectionConfirmed | UsersPermissionsUserConnectionBlocked | UsersPermissionsUserConnectionRole | UsersPermissionsUserConnection_id | UsersPermissionsUserConnectionId | UsersPermissionsUserConnectionCreatedAt | UsersPermissionsUserConnectionUpdatedAt

type Mutation {
  createArticle(input: createArticleInput): createArticlePayload
  updateArticle(input: updateArticleInput): updateArticlePayload
  deleteArticle(input: deleteArticleInput): deleteArticlePayload
  createAuthor(input: createAuthorInput): createAuthorPayload
  updateAuthor(input: updateAuthorInput): updateAuthorPayload
  deleteAuthor(input: deleteAuthorInput): deleteAuthorPayload
  createBulletPointOnSkincareProduct(input: createBulletPointOnSkincareProductInput): createBulletPointOnSkincareProductPayload
  updateBulletPointOnSkincareProduct(input: updateBulletPointOnSkincareProductInput): updateBulletPointOnSkincareProductPayload
  deleteBulletPointOnSkincareProduct(input: deleteBulletPointOnSkincareProductInput): deleteBulletPointOnSkincareProductPayload
  createCategory(input: createCategoryInput): createCategoryPayload
  updateCategory(input: updateCategoryInput): updateCategoryPayload
  deleteCategory(input: deleteCategoryInput): deleteCategoryPayload
  createSkincareProduct(input: createSkincareProductInput): createSkincareProductPayload
  updateSkincareProduct(input: updateSkincareProductInput): updateSkincareProductPayload
  deleteSkincareProduct(input: deleteSkincareProductInput): deleteSkincareProductPayload
  createSubCategory(input: createSubCategoryInput): createSubCategoryPayload
  updateSubCategory(input: updateSubCategoryInput): updateSubCategoryPayload
  deleteSubCategory(input: deleteSubCategoryInput): deleteSubCategoryPayload
  createTypeOfSkincareProduct(input: createTypeOfSkincareProductInput): createTypeOfSkincareProductPayload
  updateTypeOfSkincareProduct(input: updateTypeOfSkincareProductInput): updateTypeOfSkincareProductPayload
  deleteTypeOfSkincareProduct(input: deleteTypeOfSkincareProductInput): deleteTypeOfSkincareProductPayload

  """Create a new role"""
  createRole(input: createRoleInput): createRolePayload

  """Update an existing role"""
  updateRole(input: updateRoleInput): updateRolePayload

  """Delete an existing role"""
  deleteRole(input: deleteRoleInput): deleteRolePayload

  """Create a new user"""
  createUser(input: createUserInput): createUserPayload

  """Update an existing user"""
  updateUser(input: updateUserInput): updateUserPayload

  """Delete an existing user"""
  deleteUser(input: deleteUserInput): deleteUserPayload
  upload(refId: ID, ref: String, field: String, source: String, file: Upload!): UploadFile!
  multipleUpload(refId: ID, ref: String, field: String, source: String, files: [Upload]!): [UploadFile]!
  login(input: UsersPermissionsLoginInput!): UsersPermissionsLoginPayload!
  register(input: UserInput!): UsersPermissionsLoginPayload!
}

type Query {
  article(id: ID!): Article
  articles(sort: String, limit: Int, start: Int, where: JSON): [Article]
  articlesConnection(sort: String, limit: Int, start: Int, where: JSON): ArticleConnection
  author(id: ID!): Author
  authors(sort: String, limit: Int, start: Int, where: JSON): [Author]
  authorsConnection(sort: String, limit: Int, start: Int, where: JSON): AuthorConnection
  bulletPointOnSkincareProduct(id: ID!): BulletPointOnSkincareProduct
  bulletPointOnSkincareProducts(sort: String, limit: Int, start: Int, where: JSON): [BulletPointOnSkincareProduct]
  bulletPointOnSkincareProductsConnection(sort: String, limit: Int, start: Int, where: JSON): BulletPointOnSkincareProductConnection
  category(id: ID!): Category
  categories(sort: String, limit: Int, start: Int, where: JSON): [Category]
  categoriesConnection(sort: String, limit: Int, start: Int, where: JSON): CategoryConnection
  skincareProduct(id: ID!): SkincareProduct
  skincareProducts(sort: String, limit: Int, start: Int, where: JSON): [SkincareProduct]
  skincareProductsConnection(sort: String, limit: Int, start: Int, where: JSON): SkincareProductConnection
  subCategory(id: ID!): SubCategory
  subCategories(sort: String, limit: Int, start: Int, where: JSON): [SubCategory]
  subCategoriesConnection(sort: String, limit: Int, start: Int, where: JSON): SubCategoryConnection
  typeOfSkincareProduct(id: ID!): TypeOfSkincareProduct
  typeOfSkincareProducts(sort: String, limit: Int, start: Int, where: JSON): [TypeOfSkincareProduct]
  typeOfSkincareProductsConnection(sort: String, limit: Int, start: Int, where: JSON): TypeOfSkincareProductConnection
  files(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
  filesConnection(sort: String, limit: Int, start: Int, where: JSON): UploadFileConnection
  role(id: ID!): UsersPermissionsRole

  """
  Retrieve all the existing roles. You can't apply filters on this query.
  """
  roles(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsRole]
  rolesConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsRoleConnection
  user(id: ID!): UsersPermissionsUser
  users(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsUser]
  usersConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsUserConnection
  me: UsersPermissionsMe
}

input RoleInput {
  name: String!
  description: String
  type: String
  permissions: [ID]
  users: [ID]
}

type SkincareProduct {
  name: String
  type_of_skincare_product: TypeOfSkincareProduct
  bullet_point_on_skincare_products(sort: String, limit: Int, start: Int, where: JSON): [BulletPointOnSkincareProduct]
  _id: ID!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SkincareProductAggregator {
  count: Int
  totalCount: Int
}

type SkincareProductConnection {
  values: [SkincareProduct]
  groupBy: SkincareProductGroupBy
  aggregate: SkincareProductAggregator
}

type SkincareProductConnection_id {
  key: ID
  connection: SkincareProductConnection
}

type SkincareProductConnectionCreatedAt {
  key: DateTime
  connection: SkincareProductConnection
}

type SkincareProductConnectionId {
  key: ID
  connection: SkincareProductConnection
}

type SkincareProductConnectionName {
  key: String
  connection: SkincareProductConnection
}

type SkincareProductConnectionType_of_skincare_product {
  key: ID
  connection: SkincareProductConnection
}

type SkincareProductConnectionUpdatedAt {
  key: DateTime
  connection: SkincareProductConnection
}

type SkincareProductGroupBy {
  name: [SkincareProductConnectionName]
  type_of_skincare_product: [SkincareProductConnectionType_of_skincare_product]
  _id: [SkincareProductConnection_id]
  id: [SkincareProductConnectionId]
  createdAt: [SkincareProductConnectionCreatedAt]
  updatedAt: [SkincareProductConnectionUpdatedAt]
}

input SkincareProductInput {
  name: String
  type_of_skincare_product: ID
  bullet_point_on_skincare_products: [ID]
}

type SubCategory {
  name: String
  description: String
  category: Category
  image(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
  _id: ID!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SubCategoryAggregator {
  count: Int
  totalCount: Int
}

type SubCategoryConnection {
  values: [SubCategory]
  groupBy: SubCategoryGroupBy
  aggregate: SubCategoryAggregator
}

type SubCategoryConnection_id {
  key: ID
  connection: SubCategoryConnection
}

type SubCategoryConnectionCategory {
  key: ID
  connection: SubCategoryConnection
}

type SubCategoryConnectionCreatedAt {
  key: DateTime
  connection: SubCategoryConnection
}

type SubCategoryConnectionDescription {
  key: String
  connection: SubCategoryConnection
}

type SubCategoryConnectionId {
  key: ID
  connection: SubCategoryConnection
}

type SubCategoryConnectionName {
  key: String
  connection: SubCategoryConnection
}

type SubCategoryConnectionUpdatedAt {
  key: DateTime
  connection: SubCategoryConnection
}

type SubCategoryGroupBy {
  name: [SubCategoryConnectionName]
  description: [SubCategoryConnectionDescription]
  category: [SubCategoryConnectionCategory]
  _id: [SubCategoryConnection_id]
  id: [SubCategoryConnectionId]
  createdAt: [SubCategoryConnectionCreatedAt]
  updatedAt: [SubCategoryConnectionUpdatedAt]
}

input SubCategoryInput {
  name: String
  description: String
  image: [ID]
  category: ID
}

"""A time string with format: HH:mm:ss.SSS"""
scalar Time

type TypeOfSkincareProduct {
  name: String
  _id: ID!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TypeOfSkincareProductAggregator {
  count: Int
  totalCount: Int
}

type TypeOfSkincareProductConnection {
  values: [TypeOfSkincareProduct]
  groupBy: TypeOfSkincareProductGroupBy
  aggregate: TypeOfSkincareProductAggregator
}

type TypeOfSkincareProductConnection_id {
  key: ID
  connection: TypeOfSkincareProductConnection
}

type TypeOfSkincareProductConnectionCreatedAt {
  key: DateTime
  connection: TypeOfSkincareProductConnection
}

type TypeOfSkincareProductConnectionId {
  key: ID
  connection: TypeOfSkincareProductConnection
}

type TypeOfSkincareProductConnectionName {
  key: String
  connection: TypeOfSkincareProductConnection
}

type TypeOfSkincareProductConnectionUpdatedAt {
  key: DateTime
  connection: TypeOfSkincareProductConnection
}

type TypeOfSkincareProductGroupBy {
  name: [TypeOfSkincareProductConnectionName]
  _id: [TypeOfSkincareProductConnection_id]
  id: [TypeOfSkincareProductConnectionId]
  createdAt: [TypeOfSkincareProductConnectionCreatedAt]
  updatedAt: [TypeOfSkincareProductConnectionUpdatedAt]
}

input TypeOfSkincareProductInput {
  name: String
}

input updateArticleInput {
  where: InputID
  data: editArticleInput
}

type updateArticlePayload {
  article: Article
}

input updateAuthorInput {
  where: InputID
  data: editAuthorInput
}

type updateAuthorPayload {
  author: Author
}

input updateBulletPointOnSkincareProductInput {
  where: InputID
  data: editBulletPointOnSkincareProductInput
}

type updateBulletPointOnSkincareProductPayload {
  bulletPointOnSkincareProduct: BulletPointOnSkincareProduct
}

input updateCategoryInput {
  where: InputID
  data: editCategoryInput
}

type updateCategoryPayload {
  category: Category
}

input updateRoleInput {
  where: InputID
  data: editRoleInput
}

type updateRolePayload {
  role: UsersPermissionsRole
}

input updateSkincareProductInput {
  where: InputID
  data: editSkincareProductInput
}

type updateSkincareProductPayload {
  skincareProduct: SkincareProduct
}

input updateSubCategoryInput {
  where: InputID
  data: editSubCategoryInput
}

type updateSubCategoryPayload {
  subCategory: SubCategory
}

input updateTypeOfSkincareProductInput {
  where: InputID
  data: editTypeOfSkincareProductInput
}

type updateTypeOfSkincareProductPayload {
  typeOfSkincareProduct: TypeOfSkincareProduct
}

input updateUserInput {
  where: InputID
  data: editUserInput
}

type updateUserPayload {
  user: UsersPermissionsUser
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type UploadFile {
  name: String!
  hash: String!
  sha256: String
  ext: String
  mime: String!
  size: Float!
  url: String!
  provider: String!
  provider_metadata: JSON
  related(sort: String, limit: Int, start: Int, where: JSON): [Morph]
  _id: ID!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UploadFileAggregator {
  count: Int
  totalCount: Int
}

type UploadFileConnection {
  values: [UploadFile]
  groupBy: UploadFileGroupBy
  aggregate: UploadFileAggregator
}

type UploadFileConnection_id {
  key: ID
  connection: UploadFileConnection
}

type UploadFileConnectionCreatedAt {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionExt {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionHash {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionId {
  key: ID
  connection: UploadFileConnection
}

type UploadFileConnectionMime {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionName {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionProvider {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionProvider_metadata {
  key: JSON
  connection: UploadFileConnection
}

type UploadFileConnectionSha256 {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionSize {
  key: Float
  connection: UploadFileConnection
}

type UploadFileConnectionUpdatedAt {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionUrl {
  key: String
  connection: UploadFileConnection
}

type UploadFileGroupBy {
  name: [UploadFileConnectionName]
  hash: [UploadFileConnectionHash]
  sha256: [UploadFileConnectionSha256]
  ext: [UploadFileConnectionExt]
  mime: [UploadFileConnectionMime]
  size: [UploadFileConnectionSize]
  url: [UploadFileConnectionUrl]
  provider: [UploadFileConnectionProvider]
  provider_metadata: [UploadFileConnectionProvider_metadata]
  _id: [UploadFileConnection_id]
  id: [UploadFileConnectionId]
  createdAt: [UploadFileConnectionCreatedAt]
  updatedAt: [UploadFileConnectionUpdatedAt]
}

input UserInput {
  username: String!
  email: String!
  provider: String
  password: String
  resetPasswordToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
}

input UsersPermissionsLoginInput {
  identifier: String!
  password: String!
  provider: String = "local"
}

type UsersPermissionsLoginPayload {
  jwt: String!
  user: UsersPermissionsMe!
}

type UsersPermissionsMe {
  id: ID!
  username: String!
  email: String!
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsMeRole
}

type UsersPermissionsMeRole {
  id: ID!
  name: String!
  description: String
  type: String
}

type UsersPermissionsPermission {
  type: String!
  controller: String!
  action: String!
  enabled: Boolean!
  policy: String
  role: UsersPermissionsRole
  _id: ID!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UsersPermissionsRole {
  name: String!
  description: String
  type: String
  permissions(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsPermission]
  users(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsUser]
  _id: ID!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UsersPermissionsRoleAggregator {
  count: Int
  totalCount: Int
}

type UsersPermissionsRoleConnection {
  values: [UsersPermissionsRole]
  groupBy: UsersPermissionsRoleGroupBy
  aggregate: UsersPermissionsRoleAggregator
}

type UsersPermissionsRoleConnection_id {
  key: ID
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionCreatedAt {
  key: DateTime
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionDescription {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionId {
  key: ID
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionName {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionType {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionUpdatedAt {
  key: DateTime
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleGroupBy {
  name: [UsersPermissionsRoleConnectionName]
  description: [UsersPermissionsRoleConnectionDescription]
  type: [UsersPermissionsRoleConnectionType]
  _id: [UsersPermissionsRoleConnection_id]
  id: [UsersPermissionsRoleConnectionId]
  createdAt: [UsersPermissionsRoleConnectionCreatedAt]
  updatedAt: [UsersPermissionsRoleConnectionUpdatedAt]
}

type UsersPermissionsUser {
  username: String!
  email: String!
  provider: String
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsRole
  _id: ID!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UsersPermissionsUserAggregator {
  count: Int
  totalCount: Int
}

type UsersPermissionsUserConnection {
  values: [UsersPermissionsUser]
  groupBy: UsersPermissionsUserGroupBy
  aggregate: UsersPermissionsUserAggregator
}

type UsersPermissionsUserConnection_id {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionBlocked {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionConfirmed {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionCreatedAt {
  key: DateTime
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionEmail {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionId {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionProvider {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionRole {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionUpdatedAt {
  key: DateTime
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionUsername {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserGroupBy {
  username: [UsersPermissionsUserConnectionUsername]
  email: [UsersPermissionsUserConnectionEmail]
  provider: [UsersPermissionsUserConnectionProvider]
  confirmed: [UsersPermissionsUserConnectionConfirmed]
  blocked: [UsersPermissionsUserConnectionBlocked]
  role: [UsersPermissionsUserConnectionRole]
  _id: [UsersPermissionsUserConnection_id]
  id: [UsersPermissionsUserConnectionId]
  createdAt: [UsersPermissionsUserConnectionCreatedAt]
  updatedAt: [UsersPermissionsUserConnectionUpdatedAt]
}
